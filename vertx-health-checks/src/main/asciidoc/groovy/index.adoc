= Vert.x Health Checks

This component provides a simple way to expose health checks.

Health checks are used to express the current state
of the application in very simple terms: _UP_ or _DOWN_. This component provides a Vert.x Web handler on which you
can register procedure testing the health of the application. The handler computes the final state and returns the
result as JSON.

== Using Vert.x Health Checks

Notice that you need Vert.x Web to use this component. In addition add the following dependency:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>me.escoffier.vertx.healthchecks</groupId>
  <artifactId>vertx-health-checks</artifactId>
  <version>1.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
compile 'me.escoffier.vertx.healthchecks:vertx-health-checks:1.0-SNAPSHOT'
----

=== Registering the handler

First you need to create the health check and then register procedures checking the health:

[source]
----
import io.vertx.ext.web.Router
def healthCheckHandler = me.escoffier.vertx.healthchecks.HealthCheckHandler.create(vertx)

def router = Router.router(vertx)
// Populate the router with routes...
// Register the health check handler
router.get("/health").handler(healthCheckHandler)

----

Procedure registration is directly made on the `link:../../apidocs/me/escoffier/vertx/healthchecks/HealthCheckHandler.html[HealthCheckHandler]` instance
. It can be done at anytime, even after the route registration or at runtime:

[source]
----
Code not translatable
----

A procedure has a name, and a function (handler) executing the check. This function must not block and report to
the given `link:../../apidocs/io/vertx/core/Future.html[Future]` whether or not it succeed. Rules are the following:


* if the future is mark as failed, the check is considered as _KO_
* if the future is completed successfully but without a `link:../../apidocs/me/escoffier/vertx/healthchecks/Status.html[Status]`, the check
is considered as _OK_.
* if the future is completed successfully with a `link:../../apidocs/me/escoffier/vertx/healthchecks/Status.html[Status]` marked as _OK_,
the check is considered as _OK_.
* if the future is completed successfully with a `link:../../apidocs/me/escoffier/vertx/healthchecks/Status.html[Status]` marked as _KO_,
the check is considered as _KO_.

`link:../../apidocs/me/escoffier/vertx/healthchecks/Status.html[Status]` can also provide additional data:

[source]
----
Code not translatable
----

Procedures can be organised by groups. The procedure name indicates the group. The procedures are organized as a
tree and the structure is mapped to HTTP urls (see below).

[source]
----
def healthCheckHandler = me.escoffier.vertx.healthchecks.HealthCheckHandler.create(vertx)

// Register procedures
// Procedure can be grouped. The group is deduced using a name with "/".
// Groups can contains other group
healthCheckHandler.register("a-group/my-procedure-name", { future ->
  //....
})
healthCheckHandler.register("a-group/a-second-group/my-second-procedure-name", { future ->
  //....
})

router.get("/health").handler(healthCheckHandler)

----

== HTTP responses and JSON Output

The overall health check is retrieved using a HTTP GET on the route given when exposing the
`link:../../apidocs/me/escoffier/vertx/healthchecks/HealthCheckHandler.html[HealthCheckHandler]`.

If no procedure are registered, the response is `204 - NO CONTENT`, indicating that the system is _UP_ but no
procedures has been executed. The response does not contain a payload.

If there is at least one procedure registered, this procedure is executed and the outcome status is computed. The
response would use the following status code:

* `200` : Everything is fine
* `503` : At least one procedure has reported a non-healthy state
* `500` : One procedure has thrown an error or has not reported a status in time

The content is a JSON document indicating the overall result (`outcome`). It's either `UP` or `DOWN`. A `checks`
array is also given indicating the result of the different executed procedures. If the procedure has reported
additional data, the data is also given:

[source]
----
{
 "checks" : [
 {
   "id" : "A",
   "status" : "UP"
 },
 {
   "id" : "B",
   "status" : "DOWN",
   "data" : {
     "some-data" : "some-value"
   }
 }
 ],
 "outcome" : "DOWN"
}
----

In case of groups/ hierarchy, the `checks` array depicts this structure:

[source]
----
{
 "checks" : [
 {
   "id" : "my-group",
   "status" : "UP",
   "checks" : [
   {
     "id" : "check-2",
     "status" : "UP",
   },
   {
     "id" : "check-1",
     "status" : "UP"
   }]
 }],
 "outcome" : "UP"
}
----

If a procedure throws an error, reports a failure (exception), the JSON document provides the `cause` in the
`data` section. If a procedure does not report back before a timeout, the indicated cause is `Timeout`.

== Examples of procedures

This section provides example of common health checks.

=== JDBC

This check reports whether or not a connection to the database can be established:

[source]
----
Code not translatable
----

=== Service availability

This check reports whether or not a service (here a HTTP endpoint) is available in the service discovery:

[source]
----
Code not translatable
----

=== Event bus

This check reports whether a consumer is ready on the event bus. The protocol, in this example, is a simple
ping/pong, but it can be more sophisticated. This check can be used to check whether or not a verticle is ready
if it's listening on a specific event address.

[source]
----
Code not translatable
----

== Authentication

// TODO auth